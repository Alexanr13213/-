Составьте систему линейных уравнений для нахождения коэффициентов интерполирующего многочлена
$10$-й степени. С помощью функции scipy.linalg.cond найдите число обусловленности этой системы.
Решите составленную систему. Насколько достоверно полученное решение? С помощью построенного интерполянта
протабулируйте значение функции в промежуточных точках. Чему равны абсолютная и относительная ошибки? 
Сравните коэффициенты построенного интерполирующего многочлена с коэффициентами многочлена,
который можно получить с помощью функции numpy.polyfit. В чем разница?

Постройте кубический эрмитов интерполянт (scipy.interpolate.pchip) 
и кубический сплайн (scipy.interpolate.spline). 
Найдите значения интерполянтов в тех же точках, что и в предыдущих пунктах 
и сравните результаты.

Составленная программа должна выводить исходные точки, 
графики интерполируемой функции и интерполянтов и графики зависимости числа обусловленности 
от степени интерполяционного многочлена

import numpy as np
import matplotlib.pyplot as plt
import scipy
from scipy import special
from scipy import linalg
from scipy import interpolate
%matplotlib inline

x=[0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]
y=scipy.special.erf(x)
for i in range(0,11):
  print(x[i],y[i])

Построим по начальным точкам:

plt.title('Начальные точки')
plt.plot(x,y,'bo')
pass

Составим систему линейных уравнений для нахождения коэффициентов интерполирующего многочлена
10-й степени c помощью матрицы Вандермонда (np.vander)

W = np.vander(x)
res=scipy.linalg.solve(W,y)
res

Коэффициенты многочлена записываются в порядке убывания степени

xx = np.linspace(0.0, 1.0,20)
xx

yy = scipy.special.erf(xx)
yy

Напишем функцию linalg.cond для нахождения числа обусловленности системы, пользуясь тем,
что числом обусловленности невырожденной матрицы $A$ называется величина

def cond(A, p=2):
    return linalg.norm(A, p)*linalg.norm(linalg.inv(A), p)
cond(W)

Число обсуловленности можно рассматривать как меру близости матрицы к вырожденной.
 Чем больше число обусловленности, тем матрица ближе к вырожденной.

Найдем абсолютную и относительную ошибки.

print("Абсолютная ошибка = ", linalg.norm(W@res-y))
print("Относительная ошибка = ", linalg.norm(W@res-y)/linalg.norm(y))

f = np.polyfit(x,y,10)
f

Сравнивая коэффициенты, полученные двумя способами, видим различие только в последнем коэффициенте.
 Остальные либо совпадают, либо имеют несущественное различие.

xx = np.linspace(0.0, 1.0,100)
plt.title('График интерполяционного многочлена')
plt.plot(xx, np.polyval(f, xx),color = 'tab:blue')
plt.plot(x, y, 'or', color = 'green')
pass

f = scipy.interpolate.pchip(x,y)
xx = np.linspace(0.0, 1.0,20)
yy = f(xx)
plt.title('Кубический эрмитов интерполянт')
plt.plot(xx, yy, color = 'tab:blue')
plt.plot(x, y, 'or', color = 'green')
pass

f = scipy.interpolate.CubicSpline(x,y)
xx = np.linspace(0.0, 1.0,20)
yy = f(xx)
plt.title('Кубический сплайн')
plt.plot(xx, yy, color = 'tab:blue')
plt.plot(x, y, 'or', color = 'green')
pass

yy

Значения интерполянтов в промежуточных точках различаются,
 хоть и не очень сильно. Однако при увеличении значений точек,
 разница становится существеннее.

n_vector = []
for i in range(1,100):
  n_vector.append(i)
cond_array = []
for n in n_vector:
    _x=[]
    for i in range(0,n):
      _x+=[(i-1)/10]
    W = np.vander(_x)
    c = cond(W)
    cond_array.append(c)
plt.semilogy(n_vector, cond_array, '.')
plt.title('Зависимость числа обусловленности от степени интерполяционного многочлена')
pass