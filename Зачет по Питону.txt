import numpy as np
import matplotlib.pyplot as plt
import scipy
from scipy import special
from scipy import linalg
from scipy import interpolate
%matplotlib inline

x=[0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]
y=scipy.special.erf(x)
for i in range(0,11):
  print(x[i],y[i])

plt.title('Начальные точки')
plt.plot(x,y,'bo')
pass

W = np.vander(x)
res=scipy.linalg.solve(W,y)
res

xx = np.linspace(0.0, 1.0,20)
xx

yy = scipy.special.erf(xx)
yy

def cond(A, p=2):
    return linalg.norm(A, p)*linalg.norm(linalg.inv(A), p)
cond(W)

print("Абсолютная ошибка = ", linalg.norm(W@res-y))
print("Относительная ошибка = ", linalg.norm(W@res-y)/linalg.norm(y))

f = np.polyfit(x,y,10)
f

xx = np.linspace(0.0, 1.0,100)
plt.title('График интерполяционного многочлена')
plt.plot(xx, np.polyval(f, xx),color = 'tab:blue')
plt.plot(x, y, 'or', color = 'green')
pass

f = scipy.interpolate.pchip(x,y)
xx = np.linspace(0.0, 1.0,20)
yy = f(xx)
plt.title('Кубический эрмитов интерполянт')
plt.plot(xx, yy, color = 'tab:blue')
plt.plot(x, y, 'or', color = 'green')
pass

f = scipy.interpolate.CubicSpline(x,y)
xx = np.linspace(0.0, 1.0,20)
yy = f(xx)
plt.title('Кубический сплайн')
plt.plot(xx, yy, color = 'tab:blue')
plt.plot(x, y, 'or', color = 'green')
pass

yy

n_vector = []
for i in range(1,100):
  n_vector.append(i)
cond_array = []
for n in n_vector:
    _x=[]
    for i in range(0,n):
      _x+=[(i-1)/10]
    W = np.vander(_x)
    c = cond(W)
    cond_array.append(c)
plt.semilogy(n_vector, cond_array, '.')
plt.title('Зависимость числа обусловленности от степени интерполяционного многочлена')
pass